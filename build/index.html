<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0f0f10">
    <meta name="description" content="Examen Final - Juego de plataforma cooperativo">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Examen Final — Polarity Twins</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: #0f0f10;
            cursor: none;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            margin: 0 auto;
            width: 100%;
            height: auto;
            max-height: 100vh;
            max-width: 100vw;
            background: #111;
        }

        #cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.9;
        }

        #cursor.hover {
            filter: drop-shadow(0 0 8px #ffd700);
        }
    </style>
</head>
<body>
    <svg id="cursor" width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <radialGradient id="metalGrad" cx="50%" cy="40%" r="70%">
                <stop offset="0%" stop-color="#f6f7f8" />
                <stop offset="40%" stop-color="#d1d5d9" />
                <stop offset="100%" stop-color="#9aa0a6" />
            </radialGradient>
        </defs>
        <g>
            <circle cx="20" cy="20" r="10" fill="url(#metalGrad)" stroke="#7f858a" stroke-width="1" />
            <circle cx="20" cy="20" r="16" fill="none" stroke="#7f858a" stroke-width="1" opacity="0.6" />
        </g>
    </svg>

    <canvas id="game" width="1080" height="720"></canvas>

    <script>
        // ============================================
        // GAME BUILD - VERSIÓN BUNDLED
        // ============================================

        // Cursor customizado
        const cursorSVG = document.getElementById('cursor');
        document.addEventListener('mousemove', (e) => {
            if (cursorSVG) {
                cursorSVG.style.left = (e.clientX - 20) + 'px';
                cursorSVG.style.top = (e.clientY - 20) + 'px';
            }
        });

        // Canvas
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // ============================================
        // LOADER - Preload Assets
        // ============================================
        class GameLoader {
            static assets = new Map();
            
            static async loadAll() {
                // Preload básico sin assets reales (demo mode)
                console.log('✓ Loader ready (demo mode)');
            }

            static get(name) {
                return this.assets.get(name) || this.createFallback(name);
            }

            static createFallback(name) {
                // Crear canvas fallback para sprites
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Dibujar colores según tipo
                if (name.includes('Blue')) {
                    ctx.fillStyle = '#0066ff';
                    ctx.fillRect(10, 10, 44, 44);
                    ctx.fillStyle = '#0088ff';
                    ctx.arc(32, 32, 20, 0, Math.PI * 2);
                    ctx.fill();
                } else if (name.includes('Red')) {
                    ctx.fillStyle = '#ff0044';
                    ctx.fillRect(10, 10, 44, 44);
                    ctx.fillStyle = '#ff0066';
                    ctx.arc(32, 32, 20, 0, Math.PI * 2);
                    ctx.fill();
                } else if (name.includes('Box')) {
                    ctx.fillStyle = name.includes('blue') ? '#0066ff' : '#ff0044';
                    ctx.fillRect(5, 5, 54, 54);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(5, 5, 54, 54);
                } else if (name.includes('Button')) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.arc(32, 32, 15, 0, Math.PI * 2);
                    ctx.fill();
                } else if (name.includes('MenuBG')) {
                    const gradient = ctx.createLinearGradient(0, 0, 64, 64);
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#0f0f10');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 64, 64);
                } else {
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(0, 0, 64, 64);
                }
                
                canvas.complete = true;
                return canvas;
            }
        }

        // ============================================
        // STATE MANAGER
        // ============================================
        class StateManager {
            constructor() {
                this.state = 'menu';
            }
            change(newState) {
                this.state = newState;
            }
        }

        // ============================================
        // ENTITY BASE CLASS
        // ============================================
        class Entity {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.vx = 0;
                this.vy = 0;
            }
        }

        // ============================================
        // PHYSICS ENGINE
        // ============================================
        const Physics = {
            gravity: 980,
            friction: 0.82,
            airDrag: 0.93,

            applyGravity(entity, dt) {
                entity.vy += this.gravity * dt;
            },

            applyFriction(entity) {
                entity.vx *= this.friction;
            },

            applyAirDrag(entity) {
                entity.vx *= this.airDrag;
                entity.vy *= this.airDrag;
            },

            move(entity, dt) {
                entity.x += entity.vx * dt;
                entity.y += entity.vy * dt;
            },

            checkCollision(a, b) {
                return !(
                    a.x + a.w < b.x ||
                    a.x > b.x + b.w ||
                    a.y + a.h < b.y ||
                    a.y > b.y + b.h
                );
            },

            resolveCollision(player, solid) {
                let dx = (player.x + player.w/2) - (solid.x + solid.w/2);
                let dy = (player.y + player.h/2) - (solid.y + solid.h/2);
                let overlapX = (player.w + solid.w)/2 - Math.abs(dx);
                let overlapY = (player.h + solid.h)/2 - Math.abs(dy);

                if (overlapX < overlapY) {
                    if (dx > 0) player.x += overlapX;
                    else player.x -= overlapX;
                    player.vx = 0;
                } else {
                    if (dy > 0) player.y += overlapY;
                    else player.y -= overlapY;
                    player.vy = 0;
                }
            },

            applyCarryForce(box, direction, dt) {
                if (!box) return;
                const carrySpeed = 400;
                box.vx = direction * carrySpeed;
                box.vx *= this.friction;
            },

            stopCarryForce(box) {
                if (!box) return;
                box.vx *= 0.9;
            }
        };

        // ============================================
        // PLAYER CLASS
        // ============================================
        class Player extends Entity {
            constructor(x, y, playerType = 'blue') {
                super(x, y, 32, 32);
                this.playerType = playerType;
                this.jumpForce = -420;
                this.speed = 200;
                this.onGround = false;
                this.isDashing = false;
                this.dashDuration = 0.15;
                this.dashSpeed = 500;
                this.dashDirection = { x: 0, y: 0 };
                this.dashCooldown = 0.3;
                this.dashCooldownTimer = 0;
                this.canDash = true;
                this.dashTimer = 0;
                
                // Carga
                this.isChargingBox = false;
                this.chargeTimer = 0;
                this.chargeDuration = 5.0;
                this.chargeReloadDuration = 5.0;
                this.chargeReloadTimer = 0;
                this.chargedBox = null;
                
                // Animación
                this.animFrame = 0;
                this.animTimer = 0;
                this.animSpeed = 0.1;
                this.facingRight = true;
                this.currentState = 'idle';

                this.setupControls();
            }

            setupControls() {
                if (this.playerType === 'blue') {
                    this.controls = {
                        left: 'ArrowLeft',
                        right: 'ArrowRight',
                        jump: 'ArrowUp',
                        dash: 'k',
                        fastFall: 'ArrowDown',
                        charge: 'l'
                    };
                } else {
                    this.controls = {
                        left: 'a',
                        right: 'd',
                        jump: 'w',
                        dash: 'f',
                        fastFall: 's',
                        charge: 'c'
                    };
                }
            }

            update(dt, keys) {
                // Movimiento
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.vx = -this.speed;
                    this.facingRight = false;
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.vx = this.speed;
                    this.facingRight = true;
                } else {
                    this.vx *= 0.9;
                }

                // Salto
                if ((keys['ArrowUp'] || keys['w'] || keys['W']) && this.onGround) {
                    this.vy = this.jumpForce;
                    this.onGround = false;
                }

                // Física
                Physics.applyGravity(this, dt);
                Physics.move(this, dt);
                this.onGround = false;
            }

            draw(ctx) {
                ctx.fillStyle = this.playerType === 'blue' ? '#0066ff' : '#ff0044';
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.w, this.h);
            }
        }

        // ============================================
        // BOX CLASS
        // ============================================
        class Box extends Entity {
            constructor(x, y, type = 'blue') {
                super(x, y, 35, 35);
                this.type = type;
                this.color = type;
                this.onGround = false;
                this.isBeingCharged = false;
            }

            update(dt, level) {
                Physics.applyGravity(this, dt);
                Physics.move(this, dt);
                this.onGround = false;
                this.isBeingCharged = false;
            }

            draw(ctx) {
                ctx.fillStyle = this.type === 'blue' ? '#0066ff' : '#ff0044';
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.w, this.h);
            }
        }

        // ============================================
        // LEVEL BASE
        // ============================================
        class Level {
            constructor() {
                this.playerBlue = new Player(100, 300, 'blue');
                this.playerRed = new Player(900, 300, 'red');
                this.boxes = [
                    new Box(200, 200, 'blue'),
                    new Box(300, 200, 'blue'),
                    new Box(800, 200, 'red'),
                    new Box(900, 200, 'red'),
                ];
                this.solids = [];
                this.keys = {};
                this.isPaused = false;

                this.createLevel();
            }

            createLevel() {
                // Crear plataformas
                const tileSize = 40;
                
                // Piso
                for (let x = 0; x < 1080; x += tileSize) {
                    this.solids.push(new Entity(x, 600, tileSize, tileSize));
                }
                
                // Plataformas
                for (let x = 100; x < 400; x += tileSize) {
                    this.solids.push(new Entity(x, 450, tileSize, tileSize));
                }
                for (let x = 700; x < 1000; x += tileSize) {
                    this.solids.push(new Entity(x, 450, tileSize, tileSize));
                }
            }

            update(dt) {
                this.playerBlue.update(dt, this.keys);
                this.playerRed.update(dt, this.keys);
                
                this.boxes.forEach(b => b.update(dt, this));
                
                // Colisiones con sólidos
                this.resolveCollisions();
            }

            resolveCollisions() {
                for (let solid of this.solids) {
                    if (Physics.checkCollision(this.playerBlue, solid)) {
                        Physics.resolveCollision(this.playerBlue, solid);
                        if (this.playerBlue.vy === 0) this.playerBlue.onGround = true;
                    }
                    if (Physics.checkCollision(this.playerRed, solid)) {
                        Physics.resolveCollision(this.playerRed, solid);
                        if (this.playerRed.vy === 0) this.playerRed.onGround = true;
                    }
                    for (let box of this.boxes) {
                        if (Physics.checkCollision(box, solid)) {
                            Physics.resolveCollision(box, solid);
                            if (box.vy === 0) box.onGround = true;
                        }
                    }
                }
            }

            reset() {
                this.playerBlue.x = 100;
                this.playerBlue.y = 300;
                this.playerBlue.vx = 0;
                this.playerBlue.vy = 0;
                
                this.playerRed.x = 900;
                this.playerRed.y = 300;
                this.playerRed.vx = 0;
                this.playerRed.vy = 0;
                
                this.boxes[0].x = 200;
                this.boxes[0].y = 200;
                this.boxes[1].x = 300;
                this.boxes[1].y = 200;
                this.boxes[2].x = 800;
                this.boxes[2].y = 200;
                this.boxes[3].x = 900;
                this.boxes[3].y = 200;
            }

            draw(ctx) {
                // Fondo
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Plataformas
                ctx.fillStyle = '#444444';
                for (let solid of this.solids) {
                    ctx.fillRect(solid.x, solid.y, solid.w, solid.h);
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(solid.x, solid.y, solid.w, solid.h);
                }

                // Jugadores
                this.playerBlue.draw(ctx);
                this.playerRed.draw(ctx);

                // Cajas
                for (let box of this.boxes) {
                    box.draw(ctx);
                }

                // HUD
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText('Azul: Flechas + K/L (Dash/Cargar)', 20, 30);
                ctx.fillText('Rojo: WASD + F/C (Dash/Cargar)', 20, 50);
                ctx.fillText('R: Reiniciar | ESC: Pausar', 20, 70);
            }

            stopMusic() {}
            destroy() {}
        }

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = new StateManager();
        const Loader = GameLoader;
        let currentLevel = null;
        let currentLevelNumber = 1;

        const menuOptions = [
            { text: 'INICIAR', action: 'start', enabled: true },
            { text: 'NIVELES', action: 'levels', enabled: true },
            { text: 'CRÉDITOS', action: 'credits', enabled: true }
        ];

        const levelOptions = [
            { text: 'DEMO LEVEL', level: 1 },
            { text: '← VOLVER', action: 'back' }
        ];

        let selectedOption = 0;
        let optionHover = -1;
        let optionScale = [];
        let particles = [];

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        class Particle {
            constructor(x, y, vx, vy, size, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.size = size;
                this.color = color;
                this.life = 1;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= 0.002;
            }

            draw(ctx) {
                if (this.life > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            isDead() {
                return this.life <= 0;
            }
        }

        function createParticle() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const vx = (Math.random() - 0.5) * 20;
            const vy = Math.random() * 10 + 10;
            const size = Math.random() * 2 + 1;
            const color = ['#ff6600', '#00ff88', '#0088ff'][Math.floor(Math.random() * 3)];
            particles.push(new Particle(x, y, vx, vy, size, color));
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }
            if (particles.length < 50) {
                createParticle();
            }
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================
        function drawMenu() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Partículas
            for (let p of particles) {
                p.draw(ctx);
            }

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('POLARITY TWINS', canvas.width / 2, 100);

            ctx.font = 'bold 24px Arial';
            for (let i = 0; i < menuOptions.length; i++) {
                const y = 250 + i * 70;
                const scale = optionScale[i] || 1;
                ctx.save();
                ctx.translate(canvas.width / 2, y);
                ctx.scale(scale, scale);
                ctx.fillStyle = optionHover === i ? '#ff6600' : '#ffffff';
                ctx.fillText(menuOptions[i].text, 0, 0);
                ctx.restore();
            }

            ctx.font = '12px Arial';
            ctx.fillStyle = '#aaaaaa';
            ctx.textAlign = 'left';
            ctx.fillText('Build v1.0 - Demo', 20, canvas.height - 20);
        }

        function drawLevelSelect() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SELECCIONAR NIVEL', canvas.width / 2, 100);

            ctx.font = 'bold 24px Arial';
            for (let i = 0; i < levelOptions.length; i++) {
                const y = 250 + i * 70;
                const scale = optionScale[i] || 1;
                ctx.save();
                ctx.translate(canvas.width / 2, y);
                ctx.scale(scale, scale);
                ctx.fillStyle = optionHover === i ? '#ff6600' : '#ffffff';
                ctx.fillText(levelOptions[i].text, 0, 0);
                ctx.restore();
            }
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff6600';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSA', canvas.width / 2, 150);

            ctx.font = '16px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.fillText('R: Reiniciar | ESC: Menú', canvas.width / 2, 250);
        }

        function drawCredits() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CRÉDITOS', canvas.width / 2, 100);

            ctx.font = '18px Arial';
            ctx.fillText('Programadores: Leandro Bravo & Andrés Pérez', canvas.width / 2, 250);
            ctx.fillText('Artista: Leandro Bravo & Andrés Pérez', canvas.width / 2, 300);

            ctx.font = '12px Arial';
            ctx.fillStyle = '#aaaaaa';
            ctx.fillText('ESC para volver', canvas.width / 2, canvas.height - 50);
        }

        function loadLevel(levelNum) {
            currentLevelNumber = levelNum;
            currentLevel = new Level();
            gameState.change('game');
        }

        function handleMenuAction(action) {
            switch (action) {
                case 'start':
                    loadLevel(1);
                    break;
                case 'levels':
                    gameState.change('levelselect');
                    optionHover = -1;
                    break;
                case 'credits':
                    gameState.change('credits');
                    break;
            }
        }

        function handleLevelSelectAction(index) {
            if (levelOptions[index].action === 'back') {
                gameState.change('menu');
                optionHover = -1;
            } else {
                loadLevel(levelOptions[index].level);
            }
        }

        // ============================================
        // INPUT
        // ============================================
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (gameState.state === 'menu') {
                optionHover = -1;
                for (let i = 0; i < menuOptions.length; i++) {
                    const optY = 250 + i * 70;
                    if (Math.abs(y - optY) < 30) {
                        optionHover = i;
                        break;
                    }
                }
            } else if (gameState.state === 'levelselect') {
                optionHover = -1;
                for (let i = 0; i < levelOptions.length; i++) {
                    const optY = 250 + i * 70;
                    if (Math.abs(y - optY) < 30) {
                        optionHover = i;
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('click', () => {
            if (gameState.state === 'menu' && optionHover >= 0) {
                handleMenuAction(menuOptions[optionHover].action);
            } else if (gameState.state === 'levelselect' && optionHover >= 0) {
                handleLevelSelectAction(optionHover);
            }
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (gameState.state === 'game' && currentLevel) {
                currentLevel.keys[key] = true;
                if (key === 'escape') {
                    gameState.change('paused');
                }
                if (key === 'r') {
                    currentLevel.reset();
                }
            } else if (gameState.state === 'paused') {
                if (key === 'escape') {
                    gameState.change('game');
                }
                if (key === 'r') {
                    currentLevel.reset();
                    gameState.change('game');
                }
            } else if (gameState.state === 'menu') {
                if (key === 'enter' && optionHover >= 0) {
                    handleMenuAction(menuOptions[optionHover].action);
                }
            } else if (gameState.state === 'levelselect') {
                if (key === 'escape') {
                    gameState.change('menu');
                    optionHover = -1;
                }
            } else if (gameState.state === 'credits') {
                if (key === 'escape') {
                    gameState.change('menu');
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentLevel) {
                currentLevel.keys[e.key.toLowerCase()] = false;
            }
        });

        // ============================================
        // GAME LOOP
        // ============================================
        async function init() {
            await Loader.loadAll();
            resetOptionAnimations();
            gameState.change('menu');
            requestAnimationFrame(loop);
        }

        function resetOptionAnimations() {
            optionScale = new Array(10).fill(1);
        }

        let lastTime = 0;
        function loop(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Update
            switch (gameState.state) {
                case 'menu':
                    updateParticles(dt);
                    for (let i = 0; i < menuOptions.length; i++) {
                        if (i === optionHover) {
                            optionScale[i] = Math.min(optionScale[i] + dt * 3, 1.15);
                        } else {
                            optionScale[i] = Math.max(optionScale[i] - dt * 3, 1);
                        }
                    }
                    break;
                case 'game':
                    if (currentLevel) currentLevel.update(dt);
                    break;
                case 'levelselect':
                    for (let i = 0; i < levelOptions.length; i++) {
                        if (i === optionHover) {
                            optionScale[i] = Math.min(optionScale[i] + dt * 3, 1.15);
                        } else {
                            optionScale[i] = Math.max(optionScale[i] - dt * 3, 1);
                        }
                    }
                    break;
            }

            // Render
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            switch (gameState.state) {
                case 'menu':
                    drawMenu();
                    break;
                case 'game':
                    if (currentLevel) currentLevel.draw(ctx);
                    break;
                case 'paused':
                    if (currentLevel) currentLevel.draw(ctx);
                    drawGameOver();
                    break;
                case 'levelselect':
                    drawLevelSelect();
                    break;
                case 'credits':
                    drawCredits();
                    break;
            }

            requestAnimationFrame(loop);
        }

        // Start
        init();
    </script>
</body>
</html>
